[{"content":"安装过程  首先需要安装Hugo，安装Hugo需要利用一个包管理工具，对于Windows系统Hugo推荐了两个包管理工具，Chocolatey和Scoop，我推荐用Scoop，不需要extended version。这里介绍了如何安装Scoop。 Hugo的tutorial介绍了如何创建一个项目，其中step2（.yml的config文件）和step3（下载主题）要根据PaperMod的guide来配置。  文件介绍  content：用于放博客内容 data：不用管 layouts：自定义的HTML public：项目导出文件 resources：自定义的CSS和JavaScript static：存放的图片 themes：主题  进入themes/PaperMod则是PaperMod的相关代码，比较主要的目录有：\n assets：PaperMod的CSS和JavaScript代码 layouts：PaperMod的HTML  Config.yml 建议直接按照【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)进行配置。\n创建文章 在终端输入hugo new 文章名称.md就会在content文件夹下创建markdown文件，文章头部信息可以修改这篇文章的属性，建议按照【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)进行配置。\n本地预览  在终端输入hugo server -D启动，建议新建一个.bat文件执行这条指令。 启动服务器后，打开浏览器，本地预览网址为localhost:1313。  网站部署 我用的是GitHub Page。\n 在GitHub里创建一个仓库，名称叫做你的名字.github.io。 当我们本地预览没问题了的时候，在终端输入hugo -F --cleanDestinationDir，在public文件夹下就会生成输出文件。 我们将public文件夹作为GitHub Page的本地仓库，每次生成输出文件就推送到GitHub上，GitHub Page就会自动帮我们部署了。  多语言  如果我们想要使用多语言（中英为例），就需要在content文件夹下准备两个文件夹，例如Chinese和English，一个放中文，另一个放英文。 在config.yml中需要做以下修改：  defaultContentLanguage: en defaultContentLanguageInSubdir: true  languages:  en:  languageName: \u0026#34;English\u0026#34;  contentDir: content/English  zh:  languageName: \u0026#34;中文\u0026#34;  contentDir: content/Chinese  可以用它将中文翻译为英文。  搜索功能  分别在中英文的文件夹下创建search.md（hugo new search.md），修改文件头为：  title: \u0026#34;Search\u0026#34; date: ... draft: false layout: search  config.yml中添加：  menu: \tmain: \t-identifier: Search \tname: Search \turl: search \tweight: ... Hover 主要在themes/PaperMod/assets/css/common/header.css中修改。\n 左上角Home的hover：  .logo a:hover {  transition: 0.15s;  color: grey; }  社交媒体hover：  svg:hover {  transition: 0.15s; }  .social-icons a:nth-child(1) svg:hover{  color: #C84370 !important; }  .social-icons a:nth-child(2) svg:hover {  color: grey !important; }  ... nth-child可以设置各个图标的hover颜色。\n 黑夜模式和白天模式的hover：  #moon:hover {  transition: 0.15s;  color: deepskyblue; }  #sun:hover {  transition: 0.15s;  color: gold; }  menu中链接hover：  #menu a:hover {  transition: 0.15s;  color: grey; }  按钮hover：  在themes/PaperMod/assets/css/common/profile-mode.css中修改：\n.button:hover {  -webkit-transform: scale(1.1);  -moz-transform: scale(1.1);  -ms-transform: scale(1.1);  -o-transform: scale(1.1);  /* box-shadow: 0 0 0 1px grey; */  transform: scale(1.1) translateZ(0) translate3d(0, 0, 0) rotate(0.01deg); } 自定义社交媒体图标  利用SVG图标制作网站，比如icons8，找到我们需要的图标，例如微信。 可以利用左侧菜单栏的Stroke调节线条粗细。 点击download，SVG Embed，自定义图标大小为24*24，然后点击copy HTML。 在themes/PaperMod/layouts/partials/svg.html中粘贴复制的HTML。 需要修改为fill=currentColor stroke=currentColor，才能适应白天黑夜切换。 微信和微博的图标：  {{- else if (eq $icon_name \u0026#34;wechat\u0026#34;) -}} \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 50 50\u0026#34;\u0026gt;  \u0026lt;g fill=\u0026#34;currentColor\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34;\u0026gt;  \u0026lt;path  d=\u0026#34;M 19 6 C 9.746094 6 2 12.359375 2 20.5 C 2 24.894531 4.292969 28.679688 7.835938 31.324219 L 5.179688 39.304688 L 13.472656 34.167969 C 15.1875 34.707031 17.082031 35 19 35 C 19.746094 35 20.472656 34.945313 21.195313 34.863281 C 23.378906 39.105469 28.328125 42 34 42 C 35.722656 42 37.316406 41.675781 38.796875 41.234375 L 45.644531 45.066406 L 43.734375 38.515625 C 46.3125 36.375 48 33.394531 48 30 C 48 23.789063 42.597656 18.835938 35.75 18.105469 C 34.398438 11.125 27.324219 6 19 6 Z M 19 8 C 26.308594 8 32.328125 12.351563 33.703125 18.011719 C 26.183594 18.148438 20 23.355469 20 30 C 20 31.019531 20.160156 32.003906 20.4375 32.941406 C 19.964844 32.980469 19.484375 33 19 33 C 17.101563 33 15.199219 32.710938 13.632813 32.15625 L 13.183594 32 L 8.820313 34.699219 L 10.1875 30.59375 L 9.5625 30.171875 C 6.082031 27.820313 4 24.445313 4 20.5 C 4 13.640625 10.65625 8 19 8 Z M 13 14 C 11.898438 14 11 14.898438 11 16 C 11 17.101563 11.898438 18 13 18 C 14.101563 18 15 17.101563 15 16 C 15 14.898438 14.101563 14 13 14 Z M 25 14 C 23.898438 14 23 14.898438 23 16 C 23 17.101563 23.898438 18 25 18 C 26.101563 18 27 17.101563 27 16 C 27 14.898438 26.101563 14 25 14 Z M 34 20 C 40.746094 20 46 24.535156 46 30 C 46 32.957031 44.492188 35.550781 42.003906 37.394531 L 41.445313 37.8125 L 42.355469 40.933594 L 39.105469 39.109375 L 38.683594 39.25 C 37.285156 39.71875 35.6875 40 34 40 C 27.253906 40 22 35.464844 22 30 C 22 24.535156 27.253906 20 34 20 Z M 29.5 26 C 28.699219 26 28 26.699219 28 27.5 C 28 28.300781 28.699219 29 29.5 29 C 30.300781 29 31 28.300781 31 27.5 C 31 26.699219 30.300781 26 29.5 26 Z M 38.5 26 C 37.699219 26 37 26.699219 37 27.5 C 37 28.300781 37.699219 29 38.5 29 C 39.300781 29 40 28.300781 40 27.5 C 40 26.699219 39.300781 26 38.5 26 Z\u0026#34;\u0026gt;  \u0026lt;/path\u0026gt;  \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; {{- else if (eq $icon_name \u0026#34;weibo\u0026#34;) -}} \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 172 172\u0026#34;\u0026gt;  \u0026lt;g fill=\u0026#34;currentColor\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;4\u0026#34;\u0026gt;  \u0026lt;path  d=\u0026#34;M120.4,20.64c-2.67406,0 -5.25406,0.26875 -7.74,0.71219c-1.86781,0.3225 -3.1175,2.10969 -2.795,3.9775c0.3225,1.88125 2.10969,3.13094 3.9775,2.80844c2.17688,-0.38969 4.35375,-0.61813 6.5575,-0.61813c20.93563,0 37.84,16.90438 37.84,37.84c0,4.52844 -0.83312,8.85531 -2.31125,12.91344c-0.45687,1.16906 -0.25531,2.48594 0.5375,3.45344c0.80625,0.9675 2.05594,1.42437 3.29219,1.19594c1.23625,-0.22844 2.24406,-1.11531 2.63375,-2.29781c1.73344,-4.75687 2.72781,-9.87656 2.72781,-15.265c0,-24.65781 -20.06219,-44.72 -44.72,-44.72zM120.4,41.28c-1.46469,0 -2.84875,0.14781 -4.16562,0.37625c-1.86781,0.33594 -3.13094,2.10969 -2.795,3.99094c0.3225,1.86781 2.10969,3.1175 3.9775,2.795c1.00781,-0.17469 2.00219,-0.28219 2.98312,-0.28219c9.54063,0 17.2,7.65938 17.2,17.2c0,2.05594 -0.37625,4.01781 -1.06156,5.87219c-0.645,1.78719 0.28219,3.7625 2.06938,4.4075c1.78719,0.645 3.7625,-0.26875 4.4075,-2.05594c0.92719,-2.55312 1.46469,-5.32125 1.46469,-8.22375c0,-13.26281 -10.81719,-24.08 -24.08,-24.08zM72.46844,42.6775c-11.04562,0 -27.50656,8.66719 -42.18031,23.07219c-14.76781,14.76781 -23.40813,30.24781 -23.40813,43.57781c0,25.9075 33.12344,41.3875 65.88406,41.3875c42.47594,0 70.90969,-24.46969 70.90969,-43.91375c0,-11.87875 -10.07812,-18.35562 -19.08125,-21.23125c-2.15,-0.72562 -3.60125,-1.08844 -2.52625,-3.96406c0.72563,-1.73344 1.77375,-5.01219 1.77375,-9.36594c0,-4.945 -3.44,-9.23156 -10.32,-9.9975c-0.79281,-0.08062 -2.13656,-0.14781 -3.82969,-0.14781c-5.6975,0 -15.48,0.71219 -22.52125,3.66844c0,0 -1.38406,0.57781 -2.49938,0.57781c-1.00781,0 -1.80062,-0.48375 -1.11531,-2.37844c2.52625,-7.91469 2.16344,-14.39156 -1.80063,-18.00625c-2.23062,-2.23062 -5.42875,-3.27875 -9.28531,-3.27875zM72.46844,49.5575c1.43781,0 3.37281,0.215 4.43438,1.26313l0.1075,0.12094l0.12094,0.1075c1.54531,1.41094 1.51844,5.61687 -0.09406,10.72312c-1.38406,3.99094 -0.09406,6.75906 0.81969,8.04906c1.51844,2.16344 4.00437,3.39969 6.81281,3.39969c2.28438,0 4.39406,-0.79281 5.14656,-1.11531c5.50938,-2.31125 13.88094,-3.13094 19.87406,-3.13094c1.53187,0 2.60687,0.05375 3.07719,0.1075c2.78156,0.30906 4.1925,1.37063 4.1925,3.15781c0,3.23844 -0.77937,5.61688 -1.23625,6.73219l-0.05375,0.1075l-0.04031,0.09406c-1.075,2.88906 -1.06156,5.50938 0.04031,7.80719c1.62594,3.39969 4.82406,4.46125 6.54406,5.03906l0.28219,0.09406c5.34813,1.70656 14.2975,5.88562 14.2975,14.68719c0,7.90125 -6.81281,17.65688 -18.90656,25.16844c4.77031,-5.54969 7.47125,-12.05344 7.47125,-19.05437c0,-21.01625 -24.37562,-37.47719 -55.48344,-37.47719c-31.10781,0 -55.47,16.46094 -55.47,37.47719c0,0.645 0.01344,1.27656 0.05375,1.90812c-0.45687,-1.76031 -0.69875,-3.60125 -0.69875,-5.49594c0,-11.16656 7.59219,-24.91312 21.33875,-38.65969c14.86188,-14.59313 29.48188,-21.11031 37.36969,-21.11031zM69.875,82.33156c26.84813,0 48.60344,13.69281 48.60344,30.59719c0,16.89094 -21.75531,30.58375 -48.60344,30.58375c-26.83469,0 -48.59,-13.69281 -48.59,-30.58375c0,-16.90437 21.75531,-30.59719 48.59,-30.59719zM66.27375,89.52063c-10.38719,0.08062 -20.47875,5.76469 -24.85937,14.52594c-5.40188,11.13969 -0.36281,23.38125 12.59094,27.33187c12.95375,4.31344 28.42031,-2.16344 33.82219,-14.02875c5.38844,-11.5025 -1.43781,-23.73062 -14.39156,-26.95562c-2.365,-0.61813 -4.77031,-0.88688 -7.16219,-0.87344zM71.63531,104.06c1.98875,0 3.60125,1.59906 3.60125,3.58781c0,1.98875 -1.6125,3.60125 -3.60125,3.60125c-1.98875,0 -3.60125,-1.6125 -3.60125,-3.60125c0,-1.98875 1.6125,-3.58781 3.60125,-3.58781zM56.47781,107.64781c1.12875,0.01344 2.2575,0.18812 3.31906,0.55094c4.60906,1.46469 6.02,5.83188 3.18469,9.47344c-2.4725,3.64156 -8.12969,5.45563 -12.38938,3.64156c-4.23281,-1.81406 -5.29437,-6.19469 -2.82187,-9.46c1.85437,-2.74125 5.30781,-4.24625 8.7075,-4.20594z\u0026#34;\u0026gt;  \u0026lt;/path\u0026gt;  \u0026lt;/g\u0026gt;  \u0026lt;path d=\u0026#34;\u0026#34; fill=\u0026#34;none\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; 目录栏目放侧边 详见：Hugo博客目录放在侧边 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)。\nMarkdown渲染风格 详见：折腾 Hugo \u0026amp; PaperMod 主题 - Dvel\u0026rsquo;s Blog\n流量统计 这里我使用了不蒜子，在themes/PaperMod/layouts/partials/svg.html中修改：\n{{- if not (.Param \u0026#34;hideFooter\u0026#34;) }} \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt;  {{- if site.Copyright }} \t...  {{- end }}  \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;span id=\u0026#34;busuanzi_container\u0026#34;\u0026gt;  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\u0026#34;\u0026gt;  Visitors: \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;  Views: \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;  \u0026lt;/span\u0026gt; \u0026lt;/footer\u0026gt; {{- end }} 插入B站，YouTube视频或PPT 详见：Hugo博客自定义shortcodes | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n插入音乐播放器 详见：Hugo插入音乐播放器\n隐藏歌词：lrc-type=0\n修改全局字体 首先找到喜欢的字体，然后可以在Google Fonts中查询字体，我目前的文章字体为CodeNewRoman。Google Fonts会生成HTML和css，将HTML插入到themes/PaperMod/layouts/partials/extend_head.html中，将CSS插入到themes/PaperMod/assets/css/extended/blank.css。\nbody {  font-family: \u0026#39;Code New Roman\u0026#39;, sans-serif;  font-size: 1rem;  line-height: 1.5;  margin: 0; } 修改代码字体 与全局字体类似，区别为CSS代码插入的位置不同。\n.post-content pre, code {  font-family: \u0026#39;Code New Roman\u0026#39;, sans-serif;  max-height: 40rem; } 评论功能 详见：Hugo博客添加Twikoo评论 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n关于Outlook邮箱配置 详见：关于邮箱配置的问题？ · Discussion #249 · imaegoo/twikoo (github.com)\n自定义邮箱回复模板 详见：自定义Twikoo邮件通知模板 | Guo Le\u0026rsquo;s Blog\n代码高亮 在两个地方修改\n一个是themes/PaperMod/assets/css/common/post-single.css：\n.post-content pre code {  display: block;  margin: auto 0;  padding: 10px;  /* 主要代码颜色 */  color: #abb2bf;  font-weight: 200;  overflow-x: auto;  word-break: break-all; } 另一个是在themes/PaperMod/assets/css/hljs/an-old-hope.min.css，这是我自己修改的：\n/* 注释 */ .hljs-comment, .hljs-quote {  font-weight: 200;  color: #7f848e; }  .hljs-deletion, /* html标签 */ .hljs-name, .hljs-regexp, .hljs-tag {  font-weight: 200;  color: #e06c75; }  /* html属性 */ .hljs-tag {  font-weight: 200;  color: #d19a66; }  /* css类名 */ .hljs-template-variable, .hljs-variable, .hljs-selector-class, .hljs-selector-id {  font-weight: 200;  color: #a9b600; }  /* 内置函数 */ .hljs-built_in, .hljs-builtin-name {  font-weight: 200;  color: #56b6c2; }  /* 函数输入 */ .hljs-params {  font-weight: 200;  color: #e5c07b; }  /* 数字 */ .hljs-number {  font-weight: 200;  color: #d19a66; }  /* css属性 */ .hljs-attribute {  font-weight: 200;  color: #ee7c2b; }  /* 字符串 */ .hljs-addition, .hljs-bullet, .hljs-symbol, .hljs-string {  font-weight: 200;  color: #98c379; }  /* 函数名称 */ .hljs-section, .hljs-title {  font-weight: 200;  color: #56b6c2; }  /* 关键字 */ .hljs-keyword, .hljs-selector-tag, .hljs-literal, .hljs-link, .hljs-meta, .hljs-type {  font-weight: 200;  color: #c678dd; }  .hljs {  display: block;  overflow-x: auto;  background: #1c1d21;  color: #c0c5ce;  padding: 0.5em; }  .hljs-emphasis {  font-style: italic; }  .hljs-strong {  font-weight: 700; }  /* 选中时的背景颜色 */ .hljs ::selection, .hljs::selection {  background-color: #3d4556; } 代码边框圆角 themes/PaperMod/assets/css/common/post-single.css中修改：\n.post-content .highlight pre {  background-color: var(--theme) !important;  margin: 0; } 添加友链 详见：Hugo博客添加友链 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n","permalink":"https://kyxie.github.io/zh/blog/tech/papermod/","summary":"安装过程 首先需要安装Hugo，安装Hugo需要利用一个包管理工具，对于Windows系统Hugo推荐了两个包管理工具，Chocolatey和","title":"Hugo + PaperMod搭建技术博客"},{"content":"Character 判断是否为字母或数字：\nboolean res = Character.isLetterOrDigit(char); 转小写：\nchar res = Character.toLowerCase(char); 下一个字符：\n\u0026#39;b\u0026#39; == (char) (\u0026#39;a\u0026#39; + 1); Integer 最大值最小值：\nint max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; 比较相等：\nInteger a = 1; Integer b = 1; a == b;\t// true Integer c = 200; Integer d = 200; c == d;\t// false Objects.equals(c, d);\t// true Array 创建数组：\nint[] array = new int[5]; int[] array = new int[]{1,2,3,4}; int[] array = {1,2,3,4}; 引用：\narray[3]; 获取长度：\narray.length; 排序：\nArrays.sort(array); // int[] 不能直接做降序排列 // 想做降序排列只能用Integer[] Integer[] array = new Integer[2]; Arrays.sort(array, Comparitor.naturalOrder());\t// 升序排列 Arrays.sort(array, Comparator.reverseOrder());\t// 降序排列 二维数组排序：\nint[][] array = new int[][]{{1, 2}, {2, 3}}; Arrays.sort(array, (o1, o2) -\u0026gt; o1[0] - o2[0]);\t// 按照二维数组的第一个元素从小到大排序 Arrays.sort(array, (o1, o2) -\u0026gt; o1[1] - o2[1]);\t// 按照二维数组的第二个元素从小到大排序 打印：\nSystem.out.println(Arrays.toString(array)); 填满：\nint[] array = new int[]; int num; Arrays.fill(array, num);\t// array全部元素等于num String 创建字符串：\nString string = \u0026#34;java\u0026#34;; 指定位置的字符\nchar charAt3 = string.charAt(3);\t// charAt3 = \u0026#39;a\u0026#39; 字符串相等：\nString string1 = \u0026#34;abc\u0026#34;; String string2 = \u0026#34;abc\u0026#34;; string1.equals(string2); 字符串转整数：\nString string = \u0026#34;123\u0026#34;; int integer = Integer.parseInt(string); 字符串长度：\nint length = string.length(); 截取字符串：\nString sb = \u0026#34;abc\u0026#34;; String str = sb.substring(0, 1);\t// str = \u0026#34;a\u0026#34;; 字符的位置：\nString str = \u0026#34;abc\u0026#34;; int index = str.indexOf(b);\t// index = 1 字符串转字符数组：\nString str; char[] temp = str.toCharArray(); 字符串分割：\nString str = \u0026#34;hello world\u0026#34;; String[] word = str.split(\u0026#34; \u0026#34;);\t// word = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] // 这里必须是字符串 // 如果有两个空格连在一起，会在数组中加入一个\u0026#34;\u0026#34;（空字符串） 将字符串数组合并为长字符串（中间插入）：\nString[] words = new String[]{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; String str = String.join(\u0026#34; \u0026#34;, words); // str = \u0026#34;hello world\u0026#34;; 字符串替换：\nString str = \u0026#34;a! b\u0026#34;; str = str.replace(\u0026#34;!\u0026#34;, \u0026#34; \u0026#34;);\t// str = \u0026#34;a b\u0026#34;; // 字符或者字符串都可以替换 删除字符串头尾的空格：\nString str = \u0026#34; abc \u0026#34;; str.trim();\t// str = \u0026#34;abc\u0026#34; Stack 创建 stack：\nDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;Integer\u0026gt;(); 栈顶：\nstack.peek() 入栈：\nstack.push(); 出栈：\nstack.pop(); 栈是否为空：\nstack.isEmpty(); 栈的长度：\nstack.size(); ArrayList 创建列表：\nList\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(); List\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(Arrays.asList(1, 2, 3, 4));\t// 初始化值 添加元素：\narray.add(1); 指定位置的元素：\narray.get(0); 列表中是否存在某元素：\narray.contains(0); 删除列表元素：\narray.remove(0);\t// 删除array[0] array.remove(Integer.valueOf(0));\t// 删除元素0 列表大小：\narray.size(); 判断列表是否为空：\narray.isEmpty(); 清空列表：\narray.clear(); 升序排列：\narray.sort(Comparator.naturalOrder()); 降序排列：\narray.sort(Comparator.reverseOrder()); 修改值：\narray.set(int index, int value); 反转：\nCollections.reverse(array); HashMap 创建一个哈希映射：\nMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); 存储键值对（修改键值对）：\nmap.put(key, value); 获取 key 的内容：\nmap.get(key); 如果不知道有没有内容：\nmap.getOrDefault(key, default); // 如果存在key，返回key的值 // 如果不存在key，返回default map.put(key, map.getOrDefault(key, 0) + 1); 查询是否存在 key：\nmap.containsKey(key); 遍历键值对：\n// 遍历key for (Integer key : map.keySet()) { } // 遍历value for (Integer value : map.values()) { } 是否为空：\nmap.isEmpty(); 删除Key：\nmap.remove(key); 排序：\nMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;();\t// 创建一个哈希映射 List\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; mapList = new ArrayList\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;(map.entrySet());\t// 我们无法对HashMap排序，需要把HashMap转换为ArrayList再排序 Collections.sort(mapList, new Comparator\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;() {  public int compare(Map.Entry\u0026lt;Integer, Integer\u0026gt; o1, Map.Entry\u0026lt;Integer, Integer\u0026gt; o2) {  return (o2.getValue() - o1.getValue());\t// 按照值的大小，从大到小排序  }  }); mapList.get(i).getKey();\t// 排序后第i个的键 mapList.get(i).getValue();\t// 排序后第i个的值 HashSet 创建哈希表：\nSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;Integer\u0026gt;(); 添加元素：\nset.add(); 判断元素是否存在：\nset.contains();\t// HashSet查找元素要优于ArrayList 删除元素：\nset.remove(); 清空：\nset.clear(); 遍历：\nfor (int temp : set) {  ... } StringBuilder 创建 StringBuilder：\nStringBuilder sb = new StringBuilder(); 在末尾添加字符或字符串：\nsb.append(char); 在末尾删除字符：\nsb.deleteCharAt(sb.length() - 1); 长度：\nsb.length(); 转化为 String：\nsb.toString(); 取反：\nsb.reverse(); 插入：\nsb.insert(0, \u0026#34;abcd\u0026#34;);\t// 在第0个元素插入\u0026#34;abcd\u0026#34; 清空：\nsb.setLength(0); 取字符：\nsb.charAt(i); 修改位置的字符：\nsb.setCharAt(i); Queue 创建queue:\nQueue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;Integer\u0026gt;(); 加入元素：\nqueue.offer(1); 删除元素（先进先出）：\nqueue.poll(); 队首元素：\nqueue.peek(); 队列大小：\nqueue.size(); 是否为空：\nqueue.isEmpty(); 队列清空：\nqueue.clear(); Deque 创建Deque：\nDeque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;Integer\u0026gt;(); 队尾添加元素：\ndeque.offerLast();\t// queue的用法 队首弹出元素：\ndeque.pollFirst();\t// queue的用法 取队首元素：\ndeque.peekFirst();\t// queue的用法 队首添加元素：\ndeque.offerFirst(); 队尾弹出元素：\ndeque.pollLast(); 取队尾元素：\ndeque.peekLast(); LinkedList 新建链表：\nLinkedList\u0026lt;Integer\u0026gt; link = new LinkedList\u0026lt;Integer\u0026gt;(); 末尾插入：\nlink.add(); // 注意这个函数返回boolean，因此不要重复赋值 link.addLast(); // 返回void 指定位置插入：\nlink.add(int index, int Ele); 头部插入：\nlink.addFirst(); 清空：\nlink.clear(); 删除并返回第一个：\nlink.removeFirst(); 删除并返回最后一个：\nlink.removeLast(); 删除特定位置：\nlink.remove(int index) 重设：\nlink.set(); 头部取值：\nlink.getFirst(); 尾部取值：\nlink.getLast(); 特定位置取值：\nlink.get(int index); 是否存在：\nlink.contains(int key); PriorityQueue: 创建优先队列：\nPriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;Integer\u0026gt;(); // 如果不加Comparator默认为小根堆 // 即只有第一个元素是最小元素 插入元素：\nheap.offer(); 取堆顶：\nheap.peek(); 弹出堆顶：\nheap.poll(); 删除特定元素：\nheap.remove(); 堆大小：\nheap.size(); 互相转换 // int转String int i; String str = String.valueOf(i);  // String转int String str; int i = Integer.parseInt(str);  // char转int char ch; int i = ch - \u0026#39;0\u0026#39;;  // int转char int i; char ch = (char) (i + \u0026#39;0\u0026#39;);  // String转char[] String str; char[] ch = str.toCharArray();  // char[]转String char[] ch; String str = String.valueOf(ch);  // char转String char ch = \u0026#39;a\u0026#39;; String str = ch + \u0026#34;\u0026#34;;  // ArrayList转Integer[] List\u0026lt;Integer\u0026gt; list; Integer[] array = list.toArray(new Integer[list.size()]);  // Integer[]转ArrayList Integer[] array; List\u0026lt;Integer\u0026gt; list = Arrays.asList(array); 坑 Math.ceil：\ndouble Math.ceil(double a);\t// 原函数 Math.ceil(24 / 23);\t// 1.0 Math.ceil(22 / 23);\t// 0.0 Math.ceil((double) 24 / 23);\t// 2.0 (int) Math.ceil((double) 24 / 23);\t// 2 Math.pow:\nMath.pow(10, 9);\t// 如果想求次方必须要用pow函数，返回double 10 ^ 9;\t// 这里表示的是亦或而不是次方 二维数组：\nint[][] a = new int[][] {{1, 2}, {3, 4}}; int[] b = a[1];\t// b = [3, 4] b[1] = 100; // a = [[1, 2], [3, 100]] ","permalink":"https://kyxie.github.io/zh/blog/tech/java/","summary":"Character 判断是否为字母或数字： boolean res = Character.isLetterOrDigit(char); 转小写： char res = Character.toLowerCase(char); 下一个字符： \u0026#39;b\u0026#39; == (char) (\u0026#39;a\u0026#39; + 1); Integer 最大值最小值： int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; 比较相等： Integer a = 1; Integer b = 1; a == b; // true","title":"Java"},{"content":"char 转大小写：\nchar ch = \u0026#39;a\u0026#39;; ch = (char) toupper(ch); ch = (char) tolower(ch); 下一个字符：\n\u0026#39;b\u0026#39; == (\u0026#39;a\u0026#39; + 1); int 最大值最小值：\nint MAX = INT_MAX; int MIN = INT_MIN; array 创建数组：\nint array [4];\t// 如果不初始化则值随机 int array[] = {1,2,3,4}; int array[4] = {0};\t// {0, 0, 0, 0} // 注意只有0可以这样被初始化，其他的数是不行的 int array[4] = {1};\t// {1, 0, 0, 0}，只有第一个数被初始化为1，其他的还是默认值 引用：\narray[3]; 获取长度：\nsizeof(array) / sizeof(array[0]); 排序：\n#include \u0026lt;algorthm\u0026gt;int a[] = {5, 4, 3, 2, 1}; int n = sizeof(a) / sizeof(a[0]); // 升序 sort(a, a + n); // 降序 bool compare(int a, int b) {  return a \u0026gt; b;\t// 若改为a \u0026lt; b则为升序 } sort(a, a + n, compare); string 创建字符串：\nstring s = \u0026#34;cpp\u0026#34;; 引用\ns[0]\t// s[0] = \u0026#39;c\u0026#39; 字符串相等：\nstring s1 = \u0026#34;abc\u0026#34;; string s2 = \u0026#34;abc\u0026#34;; s1.compare(s2); // 若s1小于s2返回-1 // 若相等返回0 // 若s1大于s2返回1 字符串长度：\nint n = s.size(); 字符串连接：\ns1.append(s2); 截取字符串：\nstring s = \u0026#34;abc\u0026#34;; string sub = s.substr(0, 1);\t// str = \u0026#34;a\u0026#34;; 字符的位置：\nstring s = \u0026#34;abc\u0026#34;; s.find(\u0026#39;a\u0026#39;);\t// 从前向后查找第一个出现的\u0026#39;a\u0026#39;的位置 s.rfind(\u0026#39;a\u0026#39;);\t// 从后往前查找第一个出现的\u0026#39;a\u0026#39;的位置 s.find_first_of(\u0026#34;abc\u0026#34;);\t// 从前往后查找第一次出现在\u0026#34;abc\u0026#34;中任意字符的位置 s.find_last_of(); s.find_first_not_of(); s.find_last_not_of(); // 如果没有查询到则返回： string::npos 插入字符串：\nstring s1 = \u0026#34;abc\u0026#34;; s1.insert(1, \u0026#34;ddd\u0026#34;);\t// s1 = \u0026#34;adddbc\u0026#34; 字符串交换：\ns1.swap(s2); 字符串替换：\nstring s = \u0026#34;a! b\u0026#34;; replace(s.begin(), s.end(), \u0026#39;!\u0026#39;, \u0026#39; \u0026#39;);\t// str = \u0026#34;a b\u0026#34;; 删除字符串头尾的空格：\nstring trim(string s) {  if (s.empty())  {  return s;  }  s.erase(0, s.find_first_not_of(\u0026#34; \u0026#34;));  s.erase(s.find_last_not_of(\u0026#34; \u0026#34;) + 1);  return s; } 字符串修改：\nstring s = \u0026#34;apple\u0026#34;; s[0] = \u0026#39;b\u0026#39;; 字符串删除：\nstring s = \u0026#34;apple\u0026#34;; s.erase(bit, num);\t// bit表示开始的删除的位，num表示要删除的字符的个数 vector 定义vector：\n// 一维 vector\u0026lt;int\u0026gt; vec; vector\u0026lt;int\u0026gt; vec(3);\t// 默认值为0  // 利用数组初始化 int arr[] = {1, 2, 3}; vector\u0026lt;int\u0026gt; vec(begin(arr), end(arr));  // 二维 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec(m, vector\u0026lt;int\u0026gt;(n));\t// 长为m，宽为n 排序：\nsort(vec.begin(), vec.end());\t// 升序 sort(vec.rbegin(), vec.end());\t// 降序 取栈顶：\nvec.back(); 判断是否存在：\nif (find(vec.begin(), vec.end(), key) != vec.end()) { \t// != 表示存在 } 删除元素：\nvec.erase(vec.begin() + index);\t// 删除第index个元素 判断是否为空：\nvec.empty(); 清空列表：\nvec.clear(); 反转：\nvec.reverse(vec.begin(), vec.end()); 二维排序：\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec{{3, 4}, {1, 2}, {5, 6}}; // 按照第一列，升序排列 sort(vec.begin(), vec.end());  // 若不是，则需要写排序规则 bool compare(const vector\u0026lt;int\u0026gt; \u0026amp;a, const vector\u0026lt;int\u0026gt; \u0026amp;b) { \treturn a[1] \u0026lt; b[1];\t// 按照第二列升序 } pair 创建：\npair\u0026lt;int, int\u0026gt; p; pair\u0026lt;int, int\u0026gt; p(p1, p2); make_pair(p1, p2); 取值：\np1.first;\t// 第一个元素 p1.second;\t// 第二个元素 pair作为函数返回值：\nstd::pair\u0026lt;std::string, std::int\u0026gt; getPerson() {  return std::make_pair(\u0026#34;Kyxie\u0026#34;, 1); } std::tie(p1, p2) = getPerson(); unordered_map 创建一个哈希映射：\n#include \u0026lt;unordered_map\u0026gt;unordered_map \u0026lt;int, int\u0026gt; map; 存储键值对（修改键值对）：\nmap.insert(pair\u0026lt;int, int\u0026gt;(key, value)); map[key] = value;\t// 这种更简单 获取 key 的内容：\nmap[key]; 查询是否存在 key：\nmap.count(key);\t// 如果存在，返回1，不存在则返回0 if ((auto iter = map.find(key)) != map.end());\t// 存在则括号内为真 // iter的数据类型为 unordered_map\u0026lt;int, int\u0026gt;::iterator  if (map[key] == 0)\t// 这种最简单 遍历键值对：\nfor (auto i = map.begin(); i != map.end(); i++) {  // key: i-\u0026gt;first  // value: i-\u0026gt;second } 是否为空：\nmap.empty(); 删除Key：\nmap.erase(key); map的大小：\nmap.size(); unordered_set 遍历：\nfor (auto i = set.begin(); i != set.end(); i++) {  cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; endl; } queue 创建queue:\nqueue\u0026lt;int\u0026gt; q; 加入元素：\nq.push(1); 删除队首元素：\nq.pop();\t// 这个没有返回值 队首元素：\nq.front(); 队列大小：\nq.size(); 是否为空：\nq.empty(); 互相转换 // int转string int i; string str = to_string(i);  // string转int String str; int i = stoi(str);  // char转int char ch; int i = ch - \u0026#39;0\u0026#39;;  // int转char int i; char ch = i + \u0026#39;0\u0026#39;;  // char[]转int char s[] = \u0026#34;111\u0026#34;; int i = atoi(s);  // int转char[] int i = 111; char ch[100]; itoa(i, ch, 10); // 第一个参数为待转化的整数 // 第二个参数为输出的字符串数组 // 第三个参数为进制，范围为2 - 36  // String转char[] string str; char *ch = (char *)str.data();  // char[]转String char ch[] = \u0026#34;abcd\u0026#34;; string str(ch);  // char转String char ch = \u0026#39;a\u0026#39;; string str(1, ch);  // int[]转vector int a[] = {1, 2, 3}; vector\u0026lt;int\u0026gt; vec(a, a + sizeof(a) / sizeof(int));  // vector转int[] vector\u0026lt;int\u0026gt; vec{1, 2, 3}; int i[vec.size()]; memcpy(i, \u0026amp;vec[0], vec.size() * sizeof(vec[0])); ","permalink":"https://kyxie.github.io/zh/blog/tech/cpp/","summary":"char 转大小写： char ch = \u0026#39;a\u0026#39;; ch = (char) toupper(ch); ch = (char) tolower(ch); 下一个字符： \u0026#39;b\u0026#39; == (\u0026#39;a\u0026#39; + 1); int 最大值最小值： int MAX = INT_MAX; int MIN = INT_MIN; array 创建数组： int array [4]; // 如果不初始化则值随机 int array[] = {1,2,3,4}; int","title":"Cpp"},{"content":"链表 数据结构\npublic class ListNode {  int val;  ListNode next;  ListNode() {}  ListNode (int val) {  this.val = val;  }  ListNode (int val, ListNode next) {  this.val = val;  this.next = next;  } } 反转链表：\npublic ListNode reverse(ListNode head) {  ListNode prev = null;  ListNode curr = head;  while (curr != null) {  ListNode temp = curr.next;  curr.next = prev;  prev = curr;  curr = temp;  }  return prev; } 链表中点：\npublic ListNode mid(ListNode head) {  ListNode slow = head;  ListNode fast = head;  // 什么时候用哑节点：头节点有可能被删除的时候  while (fast != null) {  slow = slow.next;  fast = fast.next.next;  }  return slow; } 链表中点的上一个（上半部分的最后一个）：\npublic ListNode mid(ListNode head) {  ListNode slow = head;  ListNode fast = head;  while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null) {  // 少运行一次  slow = slow.next;  fast = fast.next.next;  }  return slow; } 合并两个有序链表（lc 21）：\nListNode mergeLists(ListNode l1, ListNode l2) {  if (l1 == null) {  return l2;  } else if (l2 == null) {  return l1;  } else if (l1.val \u0026lt; l2.val) {  l1.next = mergeList(l1.next, l2);  return l1;  } else {  l2.next = mergeList(l1, l2.next);  return l2;  } } 交叉合并两个链表：\nvoid merge(ListNode l1, ListNode l2) {  // l1.length() == l2.length() || l1.length() == l2.length() + 1  ListNode next1;  ListNode next2;  while (l1 != null \u0026amp;\u0026amp; n2 != null) {  next1 = l1.next;  next2 = l2.next;  l1.next = l2;  l1 = l1.next;  l2.next = l1;  l2 = l2.next;  } } 树 数据结构\npublic class TreeNode {  int val;  TreeNode left;  TreeNode right;  TreeNode() {}  TreeNode(int val) {  this.val = val;  }  TreeNode (int val, TreeNode left, TreeNode right) {  this.val = val;  this.left = left;  this.right = right;  } } 前序遍历\nList\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;Integer\u0026gt;();  public List\u0026lt;Integer\u0026gt; preTrav(TreeNode root) {  backTrack(root);  return res; }  public void backTrack(TreeNode root) {  if (root == null) {  return;  }  res.add(root.val);  backTrack(root.left);  backTrack(root.right); } 层序遍历\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelTrav(TreeNode root) {  List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;();  Queue\u0026lt;TreeNode\u0026gt; queue = new ArrayDeque\u0026lt;TreeNode\u0026gt;();  if (root != null) {  queue.offer(root);  }  while (!queue.isEmpty()) {  int n = queue.size();  List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;Integer\u0026gt;();  for (int i = 0; i \u0026lt; n; i++) {  TreeNode node = queue.poll();  level.add(node.val);  if (node.left != null) {  queue.offer(node.left);  }  if (node.right != null) {  queue.offer(node.right);  }  }  res.add(level);  }  return res; } 字典树 class Trie {  class TrieNode {  boolean end;  boolean[] next = new TrieNode[26];  }   TireNode root;  public Trie() {  root = new TrieNode();  }   public void insert(String word) {  TrieNode p = root;  for (int i = 0; i \u0026lt; word.length(); i++) {  int cur = word.charAt(i) - \u0026#39;a\u0026#39;;  if (p.next[cur] == null) {  p.next[cur] = new TrieNode();  }  p = p.next[cur];  }  p.end = true;  }   public boolean search(String word) {  TrieNode p = root;  for (int i = 0; i \u0026lt; word.length(); i++) {  int cur = word.charAt(i) - \u0026#39;a\u0026#39;;  if (p.next[cur] == null) {  return false;  }  p = p.next[cur];  }  return p.end;  } } 二分法 public int search(int[] nums, int target) {  int left = 0;  int right = nums.length - 1;  while (left \u0026lt;= right) {\t// 左闭右闭这里用\u0026lt;=  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt; target) {  left = mid + 1;  // 由于上一行已经考虑了mid的值是不合适的，因此新的区间不能再包含mid  } else if (nums[mid] \u0026gt; target) {  right = mid - 1;  } else if (nums[mid] == target) {  return mid;  }  }  return -1; } 数组最大公约数 public int arrayGCD(int[] nums) {  int gcd = 0;\t// 一定要初始化为0  for (int num : numsDivide) {  gcd = getGCD(num, gcd);  }  return gcd; }  public int getGCD(int max, int min) {  return min == 0 ? max : getGCD(min, max % min); } 质数 public boolean isPrime(int n) {  if (n == 1) {  return false;  }  for (int i = 2; i * i \u0026lt;= n; i++) {  if (n % i == 0) {  return false;  }  }  return true; } 取链表中点 ListNode fast; ListNode slow; fast = fast.next.next; slow = slow.next; 堆排序 // 一般用于寻找第k大的数 public int findKLargest(int[] nums, int k) {  int n = nums.length;  // 默认小根堆  PriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;Integer\u0026gt;();  // 堆的大小为k，先把nums的前k个元素加入heap中  for (int i = 0; i \u0026lt; k; i++) {  heap.offer(nums[i]);  }  // 考虑剩余的元素  for (int i = k; i \u0026lt; n; i++) {  Integer temp = heap.peek();\t// 当前第k大的元素  // 说明有更大的元素进来，要往后排队  if (nums[i] \u0026gt; temp) {  heap.poll();  heap.offer(nums[i]);  }  }  return heap.peek(); } 利用int判断String表示的数字是否溢出 String s = \u0026#34;222222\u0026#34;; int res = 0;\t// 要转换成的int int sign = 1;\t// 符号 int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; s.length(); i++) {  char cur = s.charAt(i);  if (cur \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; cur \u0026lt;= \u0026#39;9\u0026#39;) {  int num = cur - \u0026#39;0\u0026#39;;  if (res \u0026gt; max / 10 || (res == max / 10 \u0026amp;\u0026amp; num \u0026gt; max % 10)) {  // 除去最后一位的res \u0026gt; 除去最后一位的max  // 或者除去最后一位的res == 除去最后一位的max且最后一位 \u0026gt; max的最后一位  return max;  } else if (res \u0026lt; min / 10 || (res == min / 10) \u0026amp;\u0026amp; -num \u0026lt; max % 10) {  return min;  }  res = res * 10 + sign * num;  } } 交换两个数 a = a ^ b; b = a ^ b; a = a ^ b; 向上找到最近的2的次幂 static final int near(int a) {  int n = a - 1;  n |= n \u0026gt;\u0026gt;\u0026gt; 1;\t n |= n \u0026gt;\u0026gt;\u0026gt; 2;  n |= n \u0026gt;\u0026gt;\u0026gt; 4;  n |= n \u0026gt;\u0026gt;\u0026gt; 8;  n |= n \u0026gt;\u0026gt;\u0026gt; 16;  return (n \u0026lt; 0) ? 1 : n + 1; } ","permalink":"https://kyxie.github.io/zh/blog/tech/algorithm/","summary":"链表 数据结构 public class ListNode { int val; ListNode next; ListNode() {} ListNode (int val) { this.val = val; } ListNode (int val, ListNode next) { this.val = val; this.next = next; } } 反转链表： public ListNode reverse(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode temp = curr.next; curr.next = prev; prev =","title":"算法和数据结构"},{"content":"体验了一段时间的MacOs，不得不说MacOs真的是傻逼，右键在特定文件夹打开Terminal和新建文件这两个功能都没有，好在Mac有Automator能帮助实现这两个功能。\n打开Automator，Workflow选择no input，in Finder，左边栏Library选择Utilities，找到Run AppleScript，我们就可以新建脚本了。\n新建脚本完成之后在Finder的菜单栏的Services就可以执行脚本了\nNew File on run {input, parameters} \ttell application \u0026#34;Finder\u0026#34; \tset selection to make new file at (get insertion location) \tend tell \treturn input end run Open Terminal 首先是系统自带的Terminal：\non run {input, parameters} \ttell application \u0026#34;Finder\u0026#34;  set myWin to window 1  set thePath to (quoted form of POSIX path of (target of myWin as alias))  if application \u0026#34;Terminal\u0026#34; is running then  tell application \u0026#34;Terminal\u0026#34;  do script \u0026#34;cd \u0026#34; \u0026amp; thePath  activate  end tell  else  tell application \u0026#34;Terminal\u0026#34;  do script \u0026#34;cd \u0026#34; \u0026amp; thePath in window 1  activate  end tell  end if  end tell end run 我已经安装了iTerm2用来代替自带的Terminal，直接打开iTerm2的代码为：\non run {input, parameters} \ttell application \u0026#34;Finder\u0026#34; \tset myWin to window 1 \tset thePath to (quoted form of POSIX path of (target of myWin as alias)) \ttell application \u0026#34;iTerm\u0026#34; \tset newWindow to (create window with default profile) \ttell current session of newWindow \twrite text \u0026#34;cd \u0026#34; \u0026amp; thePath \tend tell \tend tell \tend tell end run ","permalink":"https://kyxie.github.io/zh/blog/tech/automator/","summary":"体验了一段时间的MacOs，不得不说MacOs真的是傻逼，右键在特定文件夹打开Terminal和新建文件这两个功能都没有，好在Mac有Aut","title":"Automator"},{"content":"左闭右闭 704. 二分查找 - 力扣（LeetCode）这是最基本的二分法，左闭右闭的意思是左边边界和右边边界都是可以取到的，比如[1, 1]是一个合法的区间，因此在进行while判断的时候要用\u0026lt;=。\npublic int search(int[] nums, int target) {  int left = 0;  int right = nums.length - 1;  while (left \u0026lt;= right) {\t// 左闭右闭这里用\u0026lt;=  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt; target) {  left = mid + 1;\t// 由于上一行已经考虑了mid的值是不合适的，因此新的区间不能再包含mid  } else if (nums[mid] \u0026gt; target) {  right = mid - 1;  } else if (nums[mid] == target) {  return mid;  }  }  return -1; } 左闭右开 左闭右开则是只能取区间的左边界值，比如[1, 1)就不是一个合法的区间，因为我们不能既取1又不取1。这时在进行while判断的时候要用\u0026lt;。\npublic int search(int[] nums, int target) {  int left = 0;  int right = nums.length;\t// 右开，所以right取不到  while (left \u0026lt; right) {\t// 左闭右开这里用\u0026lt;  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt; target) {  left = mid + 1;\t } else if (nums[mid] \u0026gt; target) {  right = mid;\t// 要调整右边界值，由于不包含，因此这里应该赋值为mid  } else if (nums[mid] == target) {  return mid;  }  }  return -1; } 匹配数据的最小值 875. 爱吃香蕉的珂珂 - 力扣（LeetCode）这个题求的是吃香蕉的最小速度，因此是匹配数据的最小值，我们用左闭右闭的方法来写代码：\npublic int minEatingSpeed(int[] piles, int h) {  int left = 1;  int right = 0;  for (int i = 0; i \u0026lt; piles.length; i++) {  if (piles[i] \u0026gt; right) {  right = piles[i];  }  }  while (left \u0026lt;= right) {\t// 左闭右闭  int mid = left + (right - left) / 2;  // 我们可以首先想如果相等的话会是什么结果  // 由于求的是速度的最小值，因此时间相等的话如果让right继续变小是有可能得到更小的速度的  // 因此将\u0026#34;==\u0026#34;归类到right = mid - 1  if (eatTime(piles, mid) \u0026gt; h) {  left = mid + 1;  } else {  right = mid - 1;  }  }  return left; }  public int eatTime(int[] piles, int speed) {  int time = 0;  for (int i = 0; i \u0026lt; piles.length; i++) {  time = time + (int) Math.ceil((double) piles[i] / speed);  }  return time;\t// 输出当前速度需要吃完香蕉的时间 } 模板：\npublic int searchTarget(int[] nums, int target) {  int left = 0;  int right = nums.length - 1;  while (left \u0026lt;= right) {  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt; target) {  left = mid + 1;  } else {  right = mid - 1;\t// 如果相等时，right还有可能减  }  }  return left; } 注意：如果target在nums中不存在时，返回应该插入的位置：\nnums = [0, 1, 2], target = 4\t# return 3 nums = [0, 1, 3], target = 2\t# return 2 匹配数据的最大值 34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）这个题要求找到数据的最小下标和最大下标：\npublic int searchTarget(int[] nums, int target) {  int left = 0;  int right = nums.length - 1;  while (left \u0026lt;= right) {  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt;= target) {  left = mid + 1;\t// 同理，如果相等时，left还有可能加  } else {  right = mid - 1;  }  }  return right; } 注意：如果target在nums中不存在时，返回第一个比target大的数的index - 1，如果不存在比target大的数，返回nums.length - 1\nnums = [0, 1, 2], target = -1\t# return -1 nums = [0, 1, 3], target = 2\t# return 1，第一个比2大的数是3，3的index是2，返回1 nums = [0, 1, 2], target = 3\t# return 2, nums.length - 1 = 2 ","permalink":"https://kyxie.github.io/zh/blog/tech/binarysearch/","summary":"左闭右闭 704. 二分查找 - 力扣（LeetCode）这是最基本的二分法，左闭右闭的意思是左边边界和右边边界都是可以取到的，比如[1, 1]是一个合法的","title":"二分查找"},{"content":"这几天要被背包问题给搞疯了，打算写篇文章仔细回顾回顾这一类问题。\n01背包 背包问题是指，有n件物品和最大容量为w的背包，每件物品的质量被记录在weight数组中，每件物品的价值被记录在value数组中，如何选择使得背包的价值最大。01背包指的是每件物品只能用一次。1049. 最后一块石头的重量 II就是一个01背包的问题。\n首先遍历一遍stones数组，我们能得到石头的总重量sum，然后尽可能地平分为两堆，要想两堆质量差最小，则质量小的那一堆要尽可能地接近sum的一半，我们设target = sum / 2。这时候，target即为背包的容量，stones数组即为背包的价值和重量，每个元素只能选择一次。\n二维数组 二维数组比较好理解，我们假设stones = [1, 2, 1, 4]，则target = 4。二维数组的行表示考虑前行数个物品，列表示背包容量。这里stones的长度为4，target = 4，则我们的dp数组大小应该为stones.length * (target + 1)。\n    0 1 2 3 4     0 0 1 1 1 1   1 0       2 0       3 0        第0列表示考虑背包容量为0时，可以装下的最大价值，很显然第0列什么也没法装，因此第0列可以初始化为0。同理，第0列表示背包容量为1，以此类推。\n第0行表示考虑前0号物品，当背包容量小于第0号物品的重量时，数组内容为0，当等于或大于时，数组内容为0号物品的价值。同理，第1行表示考虑前1号（即0号和1号）物品，第2行表示考虑前2号物品，以此类推。\nfor (int i = 0; i \u0026lt; stones.length; i++) {\t// 遍历物品  for (int j = 0; j \u0026lt; target + 1; j++) {\t// 遍历背包容量  if (j == 0) {  dp[i][j] = 0;\t// 初始化第一列  } else if (i == 0) {  if (j \u0026lt; nums[i]) {  dp[i][j] = 0;\t// 背包容量小于0号物品重量时  } else {  dp[i][j] = stones[i];\t// 背包容量大于等于0号物品重量时  }  } else {  ...  }  } } 初始化好了之后我们就要开始遍历了，也就是上述代码的else语句内容，分为下面两种情况：\n 如果j \u0026lt; weight[i]：则当前容量无法装下新考虑的物品，dp[i][j] = dp[i - 1][j]，即等于上一行的价值 如果j \u0026gt;= weight[i]：则我们要比较上一行的价值，和减去当前物品的容量的背包的最大容量加上新物品的价值谁大，即dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])。这里的weight[i]和value[i]都为stones[i]。  例如下表第1行第2列，i = 1, stones[1] = 2, j = 2，我们要比较dp[0][2] = 1和dp[0][0] + stones[1] = 2的大小。\n    0 1 2 3 4     0 0 1 1 1 1   1 0 1 2 3 3   2 0 1 2 3 4   3 0 1 2 3 4    因此全部的程序是这样子的：\npublic int lastStoneWeightII(int[] stones) {  int sum = 0;  for (int i = 0; i \u0026lt; stones.length; i++) {  sum += stones[i];  }  int target = sum / 2;  // 这里可以想成，在石头中找到最接近总重量一半的石头组合  int[][] dp = new int[stones.length][target + 1];  for (int i = 0; i \u0026lt; stones.length; i++) { // 遍历物品  for (int j = 0; j \u0026lt; target + 1; j++) { // 遍历背包容量  if (j == 0) {  dp[i][j] = 0; // 初始化第一列  } else if (i == 0) {  if (j \u0026lt; stones[i]) {  dp[i][j] = 0; // 背包容量小于0号物品重量时  } else {  dp[i][j] = stones[i]; // 背包容量大于等于0号物品重量时  }  } else {  if (j \u0026lt; stones[i]) {  dp[i][j] = dp[i - 1][j];  } else {  dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);  }  }  }  }  return sum - 2 * dp[stones.length - 1][target]; } 一维数组 dp数组可以被压缩为一维的，外层同样遍历物品，内层遍历背包容量，而且要倒序遍历。则dp数组的大小为target + 1。我们可以将所有元素初始化为0。\n   0 1 2 3 4     0 0 0 0 0    我们应该这么遍历：\nfor (int i = 0; i \u0026lt; stones.length; i++) {  for (int j = target; j \u0026gt;= stones[i]; j--) {  dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);  } } 下面表格第一列表示用第几个物品遍历，也就是遍历了四次，可以看到展开以后与上面的二维数组是一致的，数组的右下角表示背包容量最大时的最大价值。\n    0 1 2 3 4     0 0 1 1 1 1   1 0 1 2 3 3   2 0 1 2 3 4   3 0 1 2 3 4    完整的代码为：\npublic static int lastStoneWeightII(int[] stones) {  int sum = 0;  for (int i = 0; i \u0026lt; stones.length; i++) {  sum += stones[i];  }  int target = sum / 2;  int[] dp = new int[target + 1];  for (int i = 0; i \u0026lt; stones.length; i++) {  for (int j = target; j \u0026gt;= stones[i]; j--) {  dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);  }  }  return sum - 2 * dp[target]; } 组合数 如果题目问为达到某种要求有多少种组合，例如494. 目标和 - 力扣（LeetCode），则我们要修改dp数组的含义。之前dp数组的含义为背包容量为j时背包的最大价值为dp[j]，现在我们应该改为目标为j时，有dp[j]种组合。假设最终目标为target，dp数组的大小应为target + 1，当j = 0时我们什么都不选，这也是一种选择方式，因此我们要把dp[0]初始化为1，下面是核心代码：\nint[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i \u0026lt; nums.length; i++) {  for (int j = target; j \u0026gt;= nums[i]; j--) {  dp[j] += dp[j - nums[i]];\t// 排列组合用这个  } } 完全背包 01背包种物品只能被使用一次，而完全背包指的是物品可以被使用无限次。518. 零钱兑换 II - 力扣（LeetCode）是一道完全背包的组合题。与01背包不同，完全背包正着遍历，其他方面与01背包相同。\nint[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 0; i \u0026lt; coins.length; i++) {  for (int j = coins[i]; j \u0026lt;= amount; j++) {  dp[j] += dp[j - coins[i]];  } } 排列数 377. 组合总和 Ⅳ - 力扣（LeetCode）则是求排列数，排列数和组合数的区别在于，排列数要考虑顺序，这就导致了遍历方式也产生了不同。\n 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。  因此这道题的遍历代码应该为：\nint[] dp = new int[target + 1]; dp[0] = 1; for (int j = 0; j \u0026lt;= target; j++) {  for (int i = 0; i \u0026lt; nums.length; i++) {  if (j \u0026gt;= nums[i]) {  dp[j] += dp[j - nums[i]];  }  } } 最小数量 Loading Question\u0026hellip; - 力扣（LeetCode）这道题是求最小数量的，这时候我们的dp[j]的含义应该为总和为j时的最小硬币数量，等于dp[j - coins[i]] + 1，即，减去最后一枚硬币的面值的最小硬币数量加一。同时数组初始化的时候也应该初始化为一个比较大的数，以为要找到最小值。\nint[] dp = new int[amount + 1]; Arrays.fill(dp, 10001); dp[0] = 0; for (int i = 0; i \u0026lt; coins.length; i++) {  for (int j = coins[i]; j \u0026lt;= amount; j++) {  dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);  } } ","permalink":"https://kyxie.github.io/zh/blog/tech/backpack/","summary":"这几天要被背包问题给搞疯了，打算写篇文章仔细回顾回顾这一类问题。 01背包 背包问题是指，有n件物品和最大容量为w的背包，每件物品的质量被记录在","title":"背包问题"},{"content":"\rKyxie\u0026#39;s Blog\rHello World Printer\r\r\r \rSulv’s Blog\r记录技术、阅读、生活的博客\r\r\r 友链格式：\nname=\u0026#34;Kyxie\u0026#39;s Blog\u0026#34; url=\u0026#34;https://kyxie.github.io/zh\u0026#34; logo=\u0026#34;https://kyxie.github.io/Avatar.png\u0026#34; word=\u0026#34;Hello World Printer\u0026#34; ","permalink":"https://kyxie.github.io/zh/links/","summary":"Kyxie\u0026#39;s Blog Hello World Printer Sulv’s Blog 记录技术、阅读、生活的博客 友链格式： name=\u0026#34;Kyxie\u0026#39;s Blog\u0026#34; url=\u0026#34;https://kyxie.github.io/zh\u0026#34; logo=\u0026#34;https://kyxie.github.io/Avatar.png\u0026#34; word=\u0026#34;Hello World Printer\u0026#34;","title":"友链 🤝"},{"content":"👉️填写QQ邮箱可以自动获取QQ头像哦\n","permalink":"https://kyxie.github.io/zh/comment/comments/","summary":"👉️填写QQ邮箱可以自动获取QQ头像哦","title":"留言板 📋"},{"content":"\n\n\n\n\n","permalink":"https://kyxie.github.io/zh/blog/life/music/","summary":"","title":"最近爱听"},{"content":" 研究生项目 Turbo Wallet - 记账软件 2022年1月 至 2022年3月，JavaScript\n GitHub (前端仓库): https://github.com/Kyxie/money-management.git\nGitHub (后端仓库): https://github.com/Kyxie/money-back.git\n  这是一个帮助我们记录每天生活花费的手机App。 前端基于React.js框架，后端基于Express.js框架，数据库基于MongoDB。 可以添加，编辑和删除每一条消费记录，并且App会生成一些折线图和饼图帮助我们分析近期的消费。 还可以直观地看到哪一种消费花了多少钱，以及不同种类的消费的排序。   交通监视系统 2021年9月 至 2021年12月，Python / C++\n GitHub: https://github.com/Kyxie/Traffic.git\n  这个项目帮助当地警察局在道路交叉口安装最少的摄像头，但是获得最大的监控覆盖面积。这是一个顶点覆盖问题，我们利用CNF-SAT来对这个问题进行优化。 使用Python生成一张包含城市交通细节的地图(道路和十字路口)，然后尝试使用迪杰斯特拉算法在城市中找到最短路径，最后，我们利用CNF-SAT模拟安装摄像头是否能覆盖城市所有街道，解决顶点覆盖问题。 该项目实现了多线程和并行处理，以更高效地运行。   我的个人网站 2021年8月 至 今，HTML / CSS / JavaScript\n GitHub: https://github.com/Kyxie/Kyxie.github.io.git\n  这个项目是基于Hugo的PaperMod主题。   本科项目 基于深度学习的行人重识别系统 2020年9月 至 2021年6月，Python\n GitHub: https://github.com/Kyxie/ReID-deep-learning.git\n  本项目是基于深度学习方法的行人重识别系统，所使用的框架是PyTorch。 我们利用Market-1501数据集去训练模型，然后利用这个数据集和我们自创的UESTC Re-ID数据集去测试模型。 本项目的深度学习模型为ResNet-50，损失函数为TriHard损失。 对于Market-1501数据集的mAP指标达到58.8%，rank@1指标达到76.3%。   信道分配系统 2021年4月 至 2021年5月，MATLAB\n GitHub: https://github.com/Kyxie/Channels.git\n  这是一个关于信道分配问题的项目，项目背景为在医院中，将最高信噪比的信道分配给最需要的人（例如病人），而将普通人分配给病人的干扰信道（信噪比低）。 我们提出了4种算法去实现这个问题。   Webots机器人 2020年2月 至 2020年6月，C++\n GitHub: https://github.com/Kyxie/TDPS-2020-UESTC-Glasgow.git\nBilibili: https://www.bilibili.com/video/BV1Rp4y1S7o3?from=search\u0026amp;seid=72774621551842110\n \r.bilibili_shortcodes {\rposition: relative;\rwidth: 100%;\rheight: 0;\rpadding-bottom: 66%;\rmargin: auto;\roverflow: hidden;\rtext-align: center;\r}\r.bilibili_shortcodes iframe {\rposition: absolute;\rwidth: 100%;\rheight: 100%;\rleft: 0;\rtop: 0;\r}\r\r\r\r\r\r\r\r  这是一个基于Webots的项目。 我们在Webots软件中设计了一个智能小车和完成任务需要的场地，我们为小车安装了惯性导航模块，LIDAR模块和摄像头模块使得小车可以完成巡线，姿态解算，颜色识别等任务。   基于FPGA的波形发生器 2019年9月 至 2019年12月, Verilog\n GitHub: https://github.com/Kyxie/wave-generator.git\n  利用FPGA (Xilinx xc7a35tftg256)来生成正弦波，三角波和方波。 波的频率可调，从0 - 255Hz，并由8位USART控制。 利用4个拨码开关来控制振幅，从0 - 1V，分辨率为0.1V。 利用2个拨码开关来选择波形。 输出结果可通过VGA显示，可显示相应波形的图像信息和频率、幅值。   一个RISC架构的CPU 2018年2月 至 2018年6月, Verilog\n GitHub: https://github.com/Kyxie/CPU.git\n  使用Quartus II软件实现RISC CPU，使其能够进行加、减、乘、除操作。 CPU的设计包含数据路径模块设计（ALU，寄存器和PC），控制单元设计（状态转换和IR）以及这两个模块之间的通信（CPU的集成）。  ","permalink":"https://kyxie.github.io/zh/projects/","summary":"研究生项目 Turbo Wallet - 记账软件 2022年1月 至 2022年3月，JavaScript GitHub (前端仓库): https://github.com/Kyxie/money-management.git GitHub (后端仓库): https://github.com/Kyxie/money-back.git 这是一个帮助我们记录每天生活","title":"项目 👨‍💻"},{"content":"class Me:  def __init__(self):  self.name = \u0026#34;Kunyang Xie\u0026#34;  self.prefer_name = \u0026#34;Kyrie\u0026#34;  self.born_year = 1999  self.height = 181  self.hometown = \u0026#34;Weifang, Shandong, CN\u0026#34;  self.grad_school = \u0026#34;uWaterloo\u0026#34;  self.undergrad_school = \u0026#34;UESTC, UofG\u0026#34;  self.curr_location = \u0026#34;Waterloo, ON, CA\u0026#34; ","permalink":"https://kyxie.github.io/zh/about/","summary":"class Me: def __init__(self): self.name = \u0026#34;Kunyang Xie\u0026#34; self.prefer_name = \u0026#34;Kyrie\u0026#34; self.born_year = 1999 self.height = 181 self.hometown = \u0026#34;Weifang, Shandong, CN\u0026#34; self.grad_school = \u0026#34;uWaterloo\u0026#34; self.undergrad_school = \u0026#34;UESTC, UofG\u0026#34; self.curr_location = \u0026#34;Waterloo, ON, CA\u0026#34;","title":"关于我 👋"}]